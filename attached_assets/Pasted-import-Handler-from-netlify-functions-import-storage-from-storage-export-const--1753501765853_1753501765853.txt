import { Handler } from '@netlify/functions';
import { storage } from './storage';

export const handler: Handler = async (event, context) => {
  console.log('=== ORDERS FUNCTION INICIADA ===');
  console.log('HTTP Method:', event.httpMethod);
  console.log('Headers:', JSON.stringify(event.headers, null, 2));
  
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Content-Type': 'application/json',
  };

  if (event.httpMethod === 'OPTIONS') {
    console.log('üìã Respondendo OPTIONS request');
    return { statusCode: 200, headers };
  }

  try {
    if (event.httpMethod === 'POST') {
      console.log('üì§ Processando POST request');
      console.log('Raw body:', event.body);
      
      if (!event.body) {
        console.error('‚ùå Body vazio na requisi√ß√£o');
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'Body da requisi√ß√£o √© obrigat√≥rio',
            received: event.body 
          }),
        };
      }

      let body;
      try {
        body = JSON.parse(event.body);
        console.log('üìù Body parseado:', JSON.stringify(body, null, 2));
      } catch (parseError) {
        console.error('‚ùå Erro ao fazer parse do JSON:', parseError);
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'JSON inv√°lido',
            details: parseError.message 
          }),
        };
      }

      // Validar dados b√°sicos
      if (!body.total || isNaN(parseFloat(body.total))) {
        console.error('‚ùå Total inv√°lido:', body.total);
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'Total √© obrigat√≥rio e deve ser um n√∫mero v√°lido',
            received: body.total 
          }),
        };
      }

      console.log('üîÑ Chamando storage.createOrder...');
      const startTime = Date.now();
      
      const order = await storage.createOrder(body);
      
      const endTime = Date.now();
      console.log(`‚úÖ Order criada em ${endTime - startTime}ms`);
      console.log('üìã Order criada:', {
        id: order.id,
        status: order.status,
        pixCodePresent: !!order.pixCode,
        transactionId: order.blackCatTransactionId
      });

      return {
        statusCode: 200,
        headers,
        body: JSON.stringify(order),
      };
    }

    console.log('‚ùå M√©todo n√£o permitido:', event.httpMethod);
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: 'Method not allowed' }),
    };
    
  } catch (error) {
    console.error('‚ùå ERRO GERAL na Orders Function:');
    console.error('- Message:', error.message);
    console.error('- Stack:', error.stack);
    console.error('- Name:', error.name);
    
    // Determinar status code baseado no tipo de erro
    let statusCode = 500;
    let errorMessage = 'Erro interno do servidor';
    
    if (error.message.includes('BLACKCAT_API_KEY')) {
      statusCode = 503;
      errorMessage = 'Servi√ßo de pagamento temporariamente indispon√≠vel';
    } else if (error.message.includes('Timeout')) {
      statusCode = 504;
      errorMessage = 'Timeout ao processar pagamento';
    } else if (error.message.includes('BlackCat API Error')) {
      statusCode = 502;
      errorMessage = 'Erro no processamento do pagamento';
    }
    
    console.log('=== FIM ORDERS FUNCTION (ERRO) ===');
    
    return {
      statusCode,
      headers,
      body: JSON.stringify({ 
        error: errorMessage,
        debug: process.env.NODE_ENV === 'development' ? {
          message: error.message,
          stack: error.stack
        } : undefined,
        timestamp: new Date().toISOString()
      }),
    };
  }
};